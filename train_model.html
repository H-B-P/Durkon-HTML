<!DOCTYPE html>
<meta name="robots" content="noindex">
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Kudzu</title>
</head>
<body>
  Model: <input type="text" id="model" value="{&quot;BASE_VALUE&quot;:1000, &quot;cats&quot;:{&quot;Mackerel&quot;:{&quot;uniques&quot;:{&quot;Swedish&quot;:2.3,&quot;French&quot;:0.4},&quot;OTHER&quot;:1}}, &quot;conts&quot;:{&quot;Quality&quot;:[[0,0.2],[1,0.5],[10,1.4]]}}">
  <br>
  <br>
  Data: <textarea id="data" rows= 20 style="height: auto;">Mackerel,Quality,Price&#13;&#10;French,5,1234&#13;&#10;German,6,4321</textarea>
  <br>
  Response variable: <input type="text" id="resp" value='Price'>
  <br>
  <br>
  
  Training rounds: <input type="text" id="nrounds" value='100'>
  <br>
  Learning rate: <input type="text" id="lr" value='0.1'>
  <br>
  Loss function<select id="loss">
   <option value="Poisson">Poisson</option>
   <option value="Gamma">Gamma</option>
  </select>
  <br>
  <button onclick="train()">Train</button>
  <br>
  <div id="roundcount"></div>
  <br>
  <div id="graphSpace"></div>
  <br>
  <div id="outputSpace"></div>


<script src="https://d3js.org/d3.v7.min.js"></script>

<script src="https://unpkg.com/mathjs@11.8.0/lib/browser/math.js"></script>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

<script>

leeway=0.05
defaultValue=1
targetSpan=0.5

function prep_graphSpace(model){
 if ("cats" in model){
  for (col in model["cats"]){
   console.log(col)
   
   document.getElementById("graphSpace").innerHTML += "<br>"
   document.getElementById("graphSpace").innerHTML += '<div id="plot_'+col+'"></div>'
   document.getElementById("graphSpace").innerHTML += "<br>"
   document.getElementById("graphSpace").innerHTML += '<div id="input_'+col+'"></div>'
   
  }
 }
 if ("conts" in model){
  for (col in model["conts"]){
   console.log(col)
   
   document.getElementById("graphSpace").innerHTML += "<br>"
   document.getElementById("graphSpace").innerHTML += '<div id="plot_'+col+'"></div>'
   document.getElementById("graphSpace").innerHTML += "<br>"
   document.getElementById("graphSpace").innerHTML += '<div id="input_'+col+'"></div>'
  }
 }
}

function create_graphSpace(){
 model = document.getElementById("model").value
 model = JSON.parse(model)
 document.getElementById("graphSpace").innerHTML = ""
 prep_graphSpace(model)//.then(function(){
	 
	 
	 if ("cats" in model){
	  for (col in model["cats"]){
	   console.log(col)
	   
	   //document.getElementById("graphSpace").innerHTML += "<br>"
	   //document.getElementById("graphSpace").innerHTML += '<div id="plot_'+col+'"></div>'
	   
	   var xList = []
	   var yList = []
	   
	   for (k in model["cats"][col]["uniques"]){
	    xList.push(k)
	    yList.push(model["cats"][col]["uniques"][k])
	   }
	   if (model["cats"][col].hasOwnProperty("OTHER")){
	    xList.push("OTHER")
	    yList.push(model["cats"][col]["OTHER"])
	   }
	   
	   var plotdata = [
	   {
	    x: xList,
	    y: yList,
	    type: 'bar'
	   }
	   ]
	   
	   var layout = {
	   title: 'PDP for '+col,
	   xaxis: {
	    title: col,
	   },
	   yaxis: {
	    title: 'Multiplier',
	    range: [Math.min(Math.min(...yList)-leeway, 0, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
	   },
	   
	   height: 600,
	   width: 800
	   };
	   
	   Plotly.newPlot("plot_"+col, plotdata, layout)
	   
	  }
	 }
	 if ("conts" in model){
	  for (col in model["conts"]){
	   console.log(col)
	   
	   
	   var xList = []
	   var yList = []
	   
	   for (k in model["conts"][col]){
	    xList.push(model["conts"][col][k][0])
	    yList.push(model["conts"][col][k][1])
	   }
	   
	   
	   var plotdata = [
	   {
	    x: xList,
	    y: yList,
	    type: 'scatter',
	    mode: 'lines+markers'
	   }
	   ]
	   
	   var layout = {
	   title: 'PDP for '+col,
	   xaxis: {
	    title: col,
	   },
	   yaxis: {
	    title: 'Multiplier',
	    range: [Math.min(Math.min(...yList)-leeway, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
	   },
	   
	   height: 600,
	   width: 800
	   };
	   
	  }
	 }
 //})
 //console.log(document.getElementById("graphSpace").innerHTML)
}

function update_graphs(model) {
 
 if ("cats" in model){
  for (col in model["cats"]){
   
   var xList = []
   var yList = []
   
   
   for (k in model["cats"][col]["uniques"]){
    xList.push(k)
    yList.push(model["cats"][col]["uniques"][k])
   }
   if (model["cats"][col].hasOwnProperty("OTHER")){
    xList.push("OTHER")
    yList.push(model["cats"][col]["OTHER"])
   }
   
   var plotdata = [
   {
    x: xList,
    y: yList,
    type: 'bar',
    name: 'Multipliers'
   }
   ]
   
   var layout = {
   title: 'PDP for '+col,
   xaxis: {
    title: col,
   },
   yaxis: {
    title: 'Multiplier',
    range: [Math.min(Math.min(...yList)-leeway, 0, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
   },
   
   height: 600,
   width: 800
   };
   
   Plotly.react("plot_"+col, plotdata, layout)
   
   pred = pred*effectOfCol
  }
 }
 if ("conts" in model){
  for (col in model["conts"]){
   
   console.log(effectOfCol)
   
   var xList = []
   var yList = []
   
   for (k in model["conts"][col]){
    xList.push(model["conts"][col][k][0])
    yList.push(model["conts"][col][k][1])
   }
   
   var plotdata = [
   {
    x: xList,
    y: yList,
    type: 'scatter',
    mode: 'lines+markers',
    name: 'Multipliers'
   }
   ]
   
   var layout = {
	   title: 'PDP for '+col,
	   xaxis: {
	    title: col,
	   },
	   yaxis: {
	    title: 'Multiplier',
	    range: [Math.min(Math.min(...yList)-leeway, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
	   },
	   
	   height: 600,
	   width: 800
	   };
   
   Plotly.react("plot_"+col, plotdata, layout)
   
  }
 }
}


function getSortedKeys(obj) {
  const keys = Object.keys(obj);
  keys.sort();
  return keys;
}

function produce_cont_relevances(inputSeries, cont) { //Note: assumes inputSeries is an array.
  const reles = math.zeros([cont.length + 1, inputSeries.length]);
  
  for (p in inputSeries){
   if (inputSeries[p] < cont[0][0]){
    reles[0][p] = 1
   }
  }
  
  for (let i = 0; i < (cont.length - 1); i++) {
    x1 = cont[i][0];
    x2 = cont[i + 1][0];
    
    for (p in inputSeries){
     x = inputSeries[p]
     if (x>=x1 && x<=x2){
      reles[i][p] = (x2 - x)/(x2 - x1)
      reles[i+1][p] = (x - x1)/(x2 - x1)
     }
    }
  }
  
  for (p in inputSeries){
   if (inputSeries[p] > cont[cont.length-1][0]){
    reles[cont.length-1][p] = 1
   }
  }
  
  for (p in inputSeries){
    s = math.sum(math.subset(reles, math.index(math.range(0, cont.length), Number(p))));
    reles[cont.length][p] = 1-s
  }
  
  return math.transpose(reles); // roundabout way of doing this but the rest of the function doesn't flow as naturally if x and y don't switch places
}

function produce_cont_relevances_dict(inputDf, model){
 opDict = {}
 
 
 if ("conts" in model){
  for (col in model["conts"]){
   inputSeries = inputDf.map(d => d[col])
   opDict[col]=produce_cont_relevances(inputSeries, model['conts'][col])
  }
 }
 return opDict
}

function produce_cat_relevances(inputSeries, cat) {
  
  skeys = getSortedKeys(cat["uniques"]);
  
  reles = math.zeros([skeys.length + 1, inputSeries.length]);
  
  for (i = 0; i < skeys.length; i++) {
   for (p in inputSeries){
    if (inputSeries[p]===skeys[i]){
     reles[i][p] = 1; //d(featpred)/d(pt)
    }
   }
  }
  
  for (p in inputSeries){
    s = math.sum(math.subset(reles, math.index(math.range(0, skeys.length), Number(p))));
    reles[skeys.length][p] = 1-s
  }
  
  return math.transpose(reles); // roundabout way of doing this but the rest of the function doesn't flow as naturally if x and y don't switch places
}

function produce_cat_relevances_dict(inputDf, model){
 opDict = {}
 
 if ("cats" in model){
  for (col in model["cats"]){
   inputSeries = inputDf.map(d => d[col])
   opDict[col]=produce_cat_relevances(inputSeries, model['cats'][col])
  }
 }
 
 return opDict
}

function get_effect_of_this_cont_col_from_relevances(reles, model, col, defaultValue=1) {
  let postmultmat = [];
  for (let pt of model["conts"][col]) {
    postmultmat.push(pt[1]);
  }
  postmultmat.push(defaultValue);
  return math.multiply(reles, postmultmat);
}

function get_effects_of_cont_cols_from_relevance_dict(releDict, model) {
  let opDict = {};
  if ("conts" in model) {
    for (let col in model["conts"]) {
      opDict[col] = get_effect_of_this_cont_col_from_relevances(releDict[col], model, col);
    }
  }
  return opDict;
}

function get_effect_of_this_cat_col_from_relevances(reles, model, col) {
  let skeys = getSortedKeys(model['cats'][col]["uniques"]);
  let postmultmat = [];
  for (let key of skeys) {
    postmultmat.push(model["cats"][col]["uniques"][key]);
  }
  postmultmat.push(model["cats"][col]["OTHER"]);
  return math.multiply(reles, postmultmat);
}

function get_effects_of_cat_cols_from_relevance_dict(releDict, model) {
  let opDict = {};
  if ("cats" in model) {
    for (let col in model["cats"]) {
      opDict[col] = get_effect_of_this_cat_col_from_relevances(releDict[col], model, col);
    }
  }
  return opDict;
}

function sum_and_listify_matrix(a) {
  return a.reduce((acc, val) => acc.map((x, i) => x + val[i]));
}

function produce_total_relevances_dict(contReleDict, catReleDict) {
  let op = { "conts": {}, "cats": {} };
  for (let col in contReleDict) {
    op["conts"][col] = sum_and_listify_matrix(contReleDict[col]);
  }
  for (let col in catReleDict) {
    op["cats"][col] = sum_and_listify_matrix(catReleDict[col]);
  }
  return op;
}

function comb_from_effects_mult(base,l,contEffs,catEffs){
 op = new Array(l).fill(base)
 
 for (col in contEffs){
  op = math.dotMultiply(op,contEffs[col])
  
 }
 for (col in catEffs){
  op = math.dotMultiply(op,catEffs[col])
 }
 
 return op
}

function Gauss_grad(pred,act){
 return math.multiply(2,math.subtract(pred-act))
}

function Poisson_grad(pred,act){
 return math.dotDivide(math.subtract(pred,act),pred)
}

function Gamma_grad(pred,act){
 return math.dotDivide(math.subtract(pred,act),math.dotMultiply(pred,pred))
 //return math.divide(math.subtract(pred,act),math.multiply(pred,pred))
}

function lossgrad(pred,act){
 console.log(pred, act)
 lf = document.getElementById("loss").value
 console.log(lf)
 if (lf==="Gamma"){
 return Gamma_grad(pred,act)
 }
 if (lf==="Poisson"){
 return Poisson_grad(pred,act)
 }
}

function train(){
 model = document.getElementById("model").value
 model = JSON.parse(model)
 
 target = document.getElementById("resp").value
 nrounds = document.getElementById("nrounds").value
 lr = document.getElementById("lr").value
 
 data = document.getElementById("data").value
 data = d3.csvParse(data)
 
 document.getElementById("outputSpace").innerHTML = "Preparing . . ."
 
 create_graphSpace()
 
 train_model(data, target, nrounds, lr, model)
}

function train_model(inputDf, target, nrounds, lr, model){
 cord = produce_cont_relevances_dict(inputDf,model) //d(feat)/d(pt)
 card = produce_cat_relevances_dict(inputDf,model) //d(feat)/d(pt)
 
 tord = produce_total_relevances_dict(cord, card)
 
 resp = inputDf.map(d => d[target])
 
 i=0
 
 function train_one_step(inputDf, target,nrounds,lr,model, i,cord,card,tord,resp){
  if (i==nrounds){
   document.getElementById("roundcount").innerHTML = String(nrounds)+"/"+String(nrounds)
   document.getElementById("outputSpace").innerHTML = JSON.stringify(model)
   console.log(model)
  }
  else{
   document.getElementById("roundcount").innerHTML = String(i)+"/"+String(nrounds)
  document.getElementById("outputSpace").innerHTML = JSON.stringify(model)
  console.log(model)
  
  contEffects = get_effects_of_cont_cols_from_relevance_dict(cord,model)
  catEffects = get_effects_of_cat_cols_from_relevance_dict(card,model)
  
  pred = comb_from_effects_mult(model["BASE_VALUE"], contEffects.length, contEffects, catEffects)
  
  lossgradient = lossgrad(pred, resp)
  
  if ("conts" in model){
   for (col in model["conts"]){
    effectOfCol = contEffects[col]
    ceoc = math.dotDivide(pred,effectOfCol) //d(comb)/d(feat)
    
    finalGradients = math.multiply(math.dotMultiply(lossgradient,ceoc),cord[col]) //d(Loss)/d(pt) = d(Loss)/d(pred) * d(pred)/d(feat) * d(feat)/d(pt)
    
    for (k in model['conts'][col]){
     totRele = tord["conts"][col][k]
     if (totRele>0){
      model["conts"][col][k][1] -= finalGradients[k]*lr/totRele
     }
    }
   }
  }
  
  if ("cats" in model){
   for (col in model["cats"]){
    
    effectOfCol = catEffects[col]
    ceoc = math.dotDivide(pred,effectOfCol) //d(comb)/d(feat)
    finalGradients = math.multiply(math.dotMultiply(lossgradient,ceoc),card[col]) //d(Loss)/d(pt) = d(Loss)/d(pred) * d(pred)/d(feat) * d(feat)/d(pt)
    
    skeys = getSortedKeys(model['cats'][col]["uniques"])
    
    for (k in skeys){
     totRele = tord["cats"][col][k]
     
     
     
     if (totRele>0){
      model["cats"][col]["uniques"][skeys[k]] -= finalGradients[k]*lr/totRele
     }
    }
    
    totRele = tord["cats"][col][tord["cats"][col].length-1]
    if (totRele>0){
     model["cats"][col]["OTHER"] -= finalGradients[finalGradients.length-1]*lr/totRele
    }
   }
  }
  update_graphs(model)
   
   i++
   setTimeout(train_one_step, 0, inputDf, target,nrounds,lr,model, i,cord,card,tord,resp)
   }
  }
  train_one_step(inputDf, target,nrounds,lr,model, i,cord,card,tord,resp)
}

</script>
</body>
</html>
