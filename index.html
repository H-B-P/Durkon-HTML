<!DOCTYPE html>
<meta name="robots" content="noindex">
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>HTML Durkon</title>
  
  <style>
  /* Tooltip container */
  .tooltip {
    position: relative;
    display: inline-block;
    border-bottom: 1px dotted black; /* If you want dots under the hoverable text */
  }

  /* Tooltip text */
  .tooltip .tooltiptext {
    visibility: hidden;
    width: 400px;
    background-color: #555;
    color: #fff;
    text-align: center;
    padding: 5px 5px;
    border-radius: 6px;

    /* Position the tooltip text */
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 50%;
    /* margin-left: -60px; */

    /* Fade in tooltip */
    opacity: 0;
    transition: opacity 0.3s;
  }

  /* Show the tooltip text when you mouse over the tooltip container */
  .tooltip:hover .tooltiptext {
    visibility: visible;
    opacity: 1;
  } 
  </style>
  
</head>
<body>  
  
  <button onclick="switchToLanding()" id="landingButton">Landing Page</button>
  <button onclick="switchToPrep()" id="prepButton">Prepare Model</button>
  <button onclick="switchToTrain()" id="trainButton">Train Model</button>
  <button onclick="switchToPredict()" id="predictButton">Predict With Model</button>
  
  <br>
  <br>
  
  <div id="LandingPageDiv" style="display:inline">
   
   This is the web implementation for Durkon, a library for automatically building transparent predictive models.
   <br><br>
   You can use Prepare Model to create a starting model, use Train Model to fit it to a dataset, and use Predict With Model to apply it to new data (you will need to copypaste the model between subpages).
   <br><br>
   Check the <span class="tooltip">hovertext<span class="tooltiptext">Like this!</span></span> if you need more information.
   <br><br>
   Processing is all done client-side, in-browser: information provided stays on your computer the entire time. This also means you can model while disconnected from the internet.
   <br>
   <br>
   <br>
   NOTE: The (far more powerful) Python library this is based off is <a href = "https://www.github.com/H-B-P/DURKON">here</a>; a demo showing how to get started using it is <a href = "https://www.github.com/H-B-P/Durkon-demo-II">here</a>.
  </div>
  
  <div id="PrepPageDiv" style="display:none">
   <br>
    <span class="tooltip">Data<span class="tooltiptext">Copypaste your dataset here. Make sure it's in csv format!</span></span>: <textarea id="prepData" rows= 20 style="height: auto; width:400px;">Width,Height,Icing Thickness,Flavour,Wedding,Fancy,Price&#13;&#10;13,7,6,vanilla,No,Somewhat,63.5&#13;&#10;8,6,9,lemon,No,Somewhat,13.26&#13;&#10;13,6,6,vanilla,No,Somewhat,88.26&#13;&#10;6,6,4,marzipan,No,Somewhat,8.76&#13;&#10;8,10,5,chocolate,Yes,Somewhat,24.95&#13;&#10;7,8,10,lemon,No,Somewhat,22.06&#13;&#10;9,6,7,chocolate,No,Very,15.52</textarea>
   <br>
   <br>
   <br>
   <span class="tooltip">Categorical features<span class="tooltiptext">Predictive features which are expressed as categories: things like "Species", "Genre", or "Manufacturer_of_Car". List them with a comma between each feature name, and no spaces.</span></span>: <input type="text" id="prepCats" value='Flavour,Wedding,Fancy'>
   <br><br>
   <span class="tooltip">Continuous features<span class="tooltiptext">Predictive features which are expressed as quantities: things like "Height", "Page_Count", or "Age_of_Driver". List them with a comma between each feature name, and no spaces.</span></span>: <input type="text" id="prepConts" value='Width,Height,Icing Thickness'>
   <br><br>
   <span class="tooltip">Response variable<span class="tooltiptext">The quantity you're trying to predict. (In an Insurance context, this is usually something like "Price" or "Cost".)</span></span>: <input type="text" id="prepResp" value='Price'>
   <br><br>
   <span class="tooltip">Weight column<span class="tooltiptext"> The importance assigned to each row; leave this blank to treat all rows equally. (In an Insurance context, this is usually where you'd put Exposure when modelling Frequency or Burning Cost.)</span></span>: <input type="text" id="prepWei" value=''>
   <br><br>
   <button onclick="prep()">Prep</button>
   <br><br>
   <div id="prepOutputSpace">
   </div>
  </div>
  
  <div id="TrainPageDiv" style="display:none">
   <span class="tooltip">Model<span class="tooltiptext">The model you want to train. You can get an untrained model of the right format from Prepare Model.</span></span>: <input type="text" id="trainModel" value="{&quot;BASE_VALUE&quot;:33.75857142857143,&quot;cats&quot;:{&quot;Flavour&quot;:{&quot;OTHER&quot;:1,&quot;uniques&quot;:{&quot;vanilla&quot;:1,&quot;lemon&quot;:1,&quot;marzipan&quot;:1,&quot;chocolate&quot;:1}},&quot;Wedding&quot;:{&quot;OTHER&quot;:1,&quot;uniques&quot;:{&quot;No&quot;:1,&quot;Yes&quot;:1}},&quot;Fancy&quot;:{&quot;OTHER&quot;:1,&quot;uniques&quot;:{&quot;Somewhat&quot;:1,&quot;Very&quot;:1}}},&quot;conts&quot;:{&quot;Width&quot;:[[6,1],[7,1],[8,1],[13,1]],&quot;Height&quot;:[[6,1],[8,1],[10,1]],&quot;Icing Thickness&quot;:[[4,1],[5,1],[6,1],[9,1],[10,1]]}}">
   
   <br>
   <br>
   <span class="tooltip">Data<span class="tooltiptext">Copypaste your dataset here. Make sure it's in csv format!</span></span>: <textarea id="trainData" rows= 20 style="height: auto; width:400px">Width,Height,Icing Thickness,Flavour,Wedding,Fancy,Price&#13;&#10;13,7,6,vanilla,No,Somewhat,63.5&#13;&#10;8,6,9,lemon,No,Somewhat,13.26&#13;&#10;13,6,6,vanilla,No,Somewhat,88.26&#13;&#10;6,6,4,marzipan,No,Somewhat,8.76&#13;&#10;8,10,5,chocolate,Yes,Somewhat,24.95&#13;&#10;7,8,10,lemon,No,Somewhat,22.06&#13;&#10;9,6,7,chocolate,No,Very,15.52</textarea>
   <br><br><br>
   <span class="tooltip">Response variable<span class="tooltiptext">The quantity you're trying to predict. (In an Insurance context, this is usually something like "Price" or "Cost".)</span></span>: <input type="text" id="trainResp" value='Price'>
   <br><br>
   <span class="tooltip">Weight column<span class="tooltiptext"> The importance assigned to each row; leave this blank to treat all rows equally. (In an Insurance context, this is usually where you'd put Exposure when modelling Frequency or Burning Cost.)</span></span>: <input type="text" id="trainWei" value=''>
   <br><br><br>
   <span class="tooltip">Training rounds<span class="tooltiptext">The number of iterations you want the training algorithm to run for. More rounds are almost always better, but A) more rounds take longer to run, B) returns to adding more rounds diminish sharply, and C) overtraining makes it more likely that you'll overfit to the training data.</span></span>: <input type="text" id="nrounds" value='100'>
   <br><br>
   <span class="tooltip">Learning rate<span class="tooltiptext">The rate at which the model is trained. If training takes too long, try increasing this value; if you get crashes or other odd behaviour, try decreasing it. Note that the optimal value here will vary for different loss functions.</span></span>: <input type="text" id="lr" value='0.1'>
   <br><br>
   <span class="tooltip">Loss function<span class="tooltiptext">The error distribution the model uses to decide which mis-predictions are most important to correct. Convention is to use Gamma when predicting the price of something, Poisson when predicting how many times something will happen in a given timespan, and Tweedie for situations which are a fusion of Gamma and Poisson (such as predicting Burning Cost in an Insurance context).</span></span>: <select id="loss">
    <option value="Gamma">Gamma</option>
    <option value="Poisson">Poisson</option>
    <option value="Tweedie">Tweedie</option>
   </select>
   <br><br>
   <span class="tooltip">Tweedie Exponent<span class="tooltiptext">The 'p' parameter for the Tweedie loss function; only used when Tweedie is selected. Takes a value between 1 and 2: 1 is Poisson, 2 is Gamma, and somewhere inbetween is somewhere inbetween.</span></span>: <input type="text" id="pTweedie" value='1.5'>
   <br><br>
   <button onclick="train()">Train</button>
   <br>
   <div id="roundcount"></div>
   
   <div id="graphSpace"></div>
   <br>
   <div id="outputSpace"></div>
  </div>
  
  <div id="PredictPageDiv" style="display:none">
   <span class="tooltip">Model<span class="tooltiptext">The model you want to predict with. You can get an untrained model of the right format from Prepare Model, and train it using Train Model.</span></span>: <input type="text" id="predictModel" value= "{&quot;BASE_VALUE&quot;:33.75857142857143,&quot;cats&quot;:{&quot;Flavour&quot;:{&quot;OTHER&quot;:1,&quot;uniques&quot;:{&quot;vanilla&quot;:1.3822864527513765,&quot;lemon&quot;:0.8196884133639327,&quot;marzipan&quot;:0.6207799367604421,&quot;chocolate&quot;:0.8396236483413716}},&quot;Wedding&quot;:{&quot;OTHER&quot;:1,&quot;uniques&quot;:{&quot;No&quot;:0.984118967515344,&quot;Yes&quot;:1.031314822230211}},&quot;Fancy&quot;:{&quot;OTHER&quot;:1,&quot;uniques&quot;:{&quot;Somewhat&quot;:1.0434547682616129,&quot;Very&quot;:0.5947232406211355}}},&quot;conts&quot;:{&quot;Width&quot;:[[6,0.6207799367604421],[7,1.030806223388996],[8,0.7685872513742654],[13,1.3224683001953135]],&quot;Height&quot;:[[6,1.0572192194324284],[8,0.7226830507772818],[10,1.031314822230211]],&quot;Icing Thickness&quot;:[[4,0.6207799367604421],[5,1.031314822230211],[6,1.222139291509626],[9,0.5766959868662065],[10,1.030806223388996]]}}">
   <br>
   <br>
   <button onclick="create_inputSpace(false)" id="pSingle">Predict For Single Row</button>
   <button onclick="create_inputSpace(true)" id="pGraphs">Predict For Single Row (With Graphs)</button>
   <button onclick="create_dataset_inputSpace()" id="pDataset">Predict For Dataset</button>
   <div id="predictInputSpace">
   </div>
   <br>
   <br>
   <br>
   <div id="predictEffects"></div>
   <div id="predictOutput"></div>
  </div>
  
  <!-- All the external libraries. These are offered under different license terms to the code that uses them. -->
  
  <script src="https://d3js.org/d3.v7.min.js"></script>
  
  <script src="https://unpkg.com/mathjs@11.8.0/lib/browser/math.js"></script>
  
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  
  <script>
  
  //Switch between modes.
  
  defaultButtonText = document.getElementById('landingButton').style.color
  defaultButtonBackground = document.getElementById('landingButton').style.backgroundColor
  
  document.getElementById('landingButton').style.color = "white"
  document.getElementById('landingButton').style.backgroundColor = "black"
  
  function switchToLanding(){
   
   document.getElementById('landingButton').style.color = "white"
   document.getElementById('landingButton').style.backgroundColor = "black"
   document.getElementById('prepButton').style.color = defaultButtonText
   document.getElementById('prepButton').style.backgroundColor = defaultButtonBackground
   document.getElementById('trainButton').style.color = defaultButtonText
   document.getElementById('trainButton').style.backgroundColor = defaultButtonBackground
   document.getElementById('predictButton').style.color = defaultButtonText
   document.getElementById('predictButton').style.backgroundColor = defaultButtonBackground
   
   
   document.getElementById('LandingPageDiv').style.display = "inline"
   document.getElementById('PrepPageDiv').style.display = "none"
   document.getElementById('TrainPageDiv').style.display = "none"
   document.getElementById('PredictPageDiv').style.display = "none"
  }
  function switchToPrep(){
   
   document.getElementById('landingButton').style.color = defaultButtonText
   document.getElementById('landingButton').style.backgroundColor = defaultButtonBackground
   document.getElementById('prepButton').style.color = "white"
   document.getElementById('prepButton').style.backgroundColor = "black"
   document.getElementById('trainButton').style.color = defaultButtonText
   document.getElementById('trainButton').style.backgroundColor = defaultButtonBackground
   document.getElementById('predictButton').style.color = defaultButtonText
   document.getElementById('predictButton').style.backgroundColor = defaultButtonBackground
   
   document.getElementById('LandingPageDiv').style.display = "none"
   document.getElementById('PrepPageDiv').style.display = "inline"
   document.getElementById('TrainPageDiv').style.display = "none"
   document.getElementById('PredictPageDiv').style.display = "none"
  }
  function switchToTrain(){
   
   document.getElementById('landingButton').style.color = defaultButtonText
   document.getElementById('landingButton').style.backgroundColor = defaultButtonBackground
   document.getElementById('prepButton').style.color = defaultButtonText
   document.getElementById('prepButton').style.backgroundColor = defaultButtonBackground
   document.getElementById('trainButton').style.color = "white"
   document.getElementById('trainButton').style.backgroundColor = "black"
   document.getElementById('predictButton').style.color = defaultButtonText
   document.getElementById('predictButton').style.backgroundColor = defaultButtonBackground
   
   document.getElementById('LandingPageDiv').style.display = "none"
   document.getElementById('PrepPageDiv').style.display = "none"
   document.getElementById('TrainPageDiv').style.display = "inline"
   document.getElementById('PredictPageDiv').style.display = "none"
  }
  function switchToPredict(){
   
   document.getElementById('landingButton').style.color = defaultButtonText
   document.getElementById('landingButton').style.backgroundColor = defaultButtonBackground
   document.getElementById('prepButton').style.color = defaultButtonText
   document.getElementById('prepButton').style.backgroundColor = defaultButtonBackground
   document.getElementById('trainButton').style.color = defaultButtonText
   document.getElementById('trainButton').style.backgroundColor = defaultButtonBackground
   document.getElementById('predictButton').style.color = "white"
   document.getElementById('predictButton').style.backgroundColor = "black"
   
   document.getElementById('LandingPageDiv').style.display = "none"
   document.getElementById('PrepPageDiv').style.display = "none"
   document.getElementById('TrainPageDiv').style.display = "none"
   document.getElementById('PredictPageDiv').style.display = "inline"
  }
  
  //Functions for Prep
  
  function prep() {
   
   cats = document.getElementById("prepCats").value.split(",")
   conts = document.getElementById("prepConts").value.split(",")
   
   resp = document.getElementById("prepResp").value
   wei = document.getElementById("prepWei").value
   
   data = document.getElementById("prepData").value
   data = d3.csvParse(data)
   
   console.log("WEI WEI WEI")
   console.log(wei)
   
   if (wei!=""){
    
    var sumOfProducts = d3.sum(data, function(d) {
     return +d[resp] * +d[wei];
    });
 
    var sumOfWei = d3.sum(data, function(d) {
     return +d[wei];
    });
    
    meanResp = sumOfProducts/sumOfWei
   
   }else{
    
    var resps = data.map(function(d) { return +d[resp]; });
    var meanResp = d3.mean(resps);
   
   }
   
   console.log(wei)
   
   model = {"BASE_VALUE": meanResp, "cats":{}, "conts":{}}
   
   for (cat in cats){
    cat = cats[cat]
    if (cat!=""){
     model["cats"][cat] = get_cat_feat(data, cat, undefined, undefined, wei)
    }
   }
   
   for (cont in conts){
    cont = conts[cont]
    if (cont!=""){
     model["conts"][cont] = get_cont_feat(data, cont, undefined, undefined, undefined, weightCol=wei)
    }
   }
   
   console.log(model)
   
   output = JSON.stringify(model)
   
   document.getElementById("prepOutputSpace").innerHTML = "Prepared Model: " + output
  }

  function get_cat_feat(df, cat, catMinPrev=0.01, defaultValue=1, weightCol="") {
    if (weightCol === "") {
      df.forEach((d) => {
        d["WEIGHT_COL"] = 1;
      });
    } else {
      df.forEach((d) => {
        d["WEIGHT_COL"] = parseFloat(d[weightCol]);
      });
    }
    
    const sw = df.reduce((a, b) => a + b["WEIGHT_COL"], 0);
    
    console.log(sw)
    
    const feat = { "OTHER": defaultValue, "uniques": {} };
    
    console.log(feat)
    
    const uniqueValues = Array.from(new Set(df.map((d) => d[cat])));
    
    console.log(uniqueValues)
    
    uniqueValues.forEach((u) => {
      const filteredData = df.filter((d) => d[cat] === u);
      const valueSum = filteredData.reduce((a, b) => a + b["WEIGHT_COL"], 0);
      if (valueSum / sw > catMinPrev) {
        feat["uniques"][u] = defaultValue;
      }
    });
    
    return feat;
  }

  function get_cont_feat(df, cont, contTargetPts=5, edge=0.01, defaultValue=1, weightCol="") {
    if (weightCol === "") {
      df.forEach((d) => {
        d["WEIGHT_COL"] = 1;
      });
    } else {
      df.forEach((d) => {
        d["WEIGHT_COL"] = parseFloat(d[weightCol]);
      });
    }
    
    df = df.filter((d) => !isNaN(d[cont]));
    
    const sw = df.reduce((a, b) => a + b["WEIGHT_COL"], 0);
    
    const inpts = [];
    for (let i = 0; i < contTargetPts; i++) {
      inpts.push(edge + (1 - edge * 2) * i / (contTargetPts - 1));
    }
    
    console.log(inpts)
    
    df = df.sort((a, b) => a[cont] - b[cont]).map((d, i) => ({ ...d, index: i }));
    
    let cumsum = 0;
    df.forEach((d) => {
      cumsum += d["WEIGHT_COL"];
      d["CSWC"] = cumsum;
    });
    
    console.log(df)
    
    pts = [];
    feat = [];
    
    inpts.forEach((inpt) => {
      newpt = Math.min(...df.filter((d) => d["CSWC"] >= inpt * sw).map((d) => d[cont]));
      console.log(newpt)
      if (!pts.includes(newpt)) {
        pts.push(newpt);
      }
    });
    
    console.log(pts)
    
    pts.forEach((pt) => {
      feat.push([pt, defaultValue]);
    });
    
    return feat;
  }
  
  //Functions for Train
  
  leeway=0.05
  defaultValue=1
  targetSpan=0.5

  function prep_graphSpace(model){
   if ("cats" in model){
    for (col in model["cats"]){
     console.log(col)
     
     document.getElementById("graphSpace").innerHTML += '<div id="plot_'+col+'"></div>'
     document.getElementById("graphSpace").innerHTML += "<br>"
     document.getElementById("graphSpace").innerHTML += '<div id="input_'+col+'"></div>'
     document.getElementById("graphSpace").innerHTML += "<br>"
     
    }
   }
   if ("conts" in model){
    for (col in model["conts"]){
     console.log(col)
     
     document.getElementById("graphSpace").innerHTML += "<br>"
     document.getElementById("graphSpace").innerHTML += '<div id="plot_'+col+'"></div>'
     document.getElementById("graphSpace").innerHTML += "<br>"
     document.getElementById("graphSpace").innerHTML += '<div id="input_'+col+'"></div>'
    }
   }
  }

  function create_graphSpace(){
   model = document.getElementById("trainModel").value
   model = JSON.parse(model)
   document.getElementById("graphSpace").innerHTML = ""
   prep_graphSpace(model)//.then(function(){
    
    
    if ("cats" in model){
     for (col in model["cats"]){
      console.log(col)
      
      var xList = []
      var yList = []
      
      for (k in model["cats"][col]["uniques"]){
       xList.push(k)
       yList.push(model["cats"][col]["uniques"][k])
      }
      if (model["cats"][col].hasOwnProperty("OTHER")){
       xList.push("OTHER")
       yList.push(model["cats"][col]["OTHER"])
      }
      
      var plotdata = [
      {
       x: xList,
       y: yList,
       type: 'bar'
      }
      ]
      
      var layout = {
      title: 'PDP for '+col,
      xaxis: {
       title: col,
      },
      yaxis: {
       title: 'Multiplier',
       range: [Math.min(Math.min(...yList)-leeway, 0, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
      },
      
      height: 600,
      width: 800
      };
      
      Plotly.newPlot("plot_"+col, plotdata, layout)
      
     }
    }
    if ("conts" in model){
     for (col in model["conts"]){
      console.log(col)
      
      
      var xList = []
      var yList = []
      
      for (k in model["conts"][col]){
       xList.push(model["conts"][col][k][0])
       yList.push(model["conts"][col][k][1])
      }
      
      
      var plotdata = [
      {
       x: xList,
       y: yList,
       type: 'scatter',
       mode: 'lines+markers'
      }
      ]
      
      var layout = {
      title: 'PDP for '+col,
      xaxis: {
       title: col,
      },
      yaxis: {
       title: 'Multiplier',
       range: [Math.min(Math.min(...yList)-leeway, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
      },
      
      height: 600,
      width: 800
      };
      
     }
    }
  }

  function update_graphs(model) {
   
   if ("cats" in model){
    for (col in model["cats"]){
     
     var xList = []
     var yList = []
     
     
     for (k in model["cats"][col]["uniques"]){
      xList.push(k)
      yList.push(model["cats"][col]["uniques"][k])
     }
     if (model["cats"][col].hasOwnProperty("OTHER")){
      xList.push("OTHER")
      yList.push(model["cats"][col]["OTHER"])
     }
     
     var plotdata = [
     {
      x: xList,
      y: yList,
      type: 'bar',
      name: 'Multipliers'
     }
     ]
     
     var layout = {
     title: 'PDP for '+col,
     xaxis: {
      title: col,
     },
     yaxis: {
      title: 'Multiplier',
      range: [Math.min(Math.min(...yList)-leeway, 0, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
     },
     
     height: 600,
     width: 800
     };
     
     Plotly.react("plot_"+col, plotdata, layout)
     
     pred = pred*effectOfCol
    }
   }
   if ("conts" in model){
    for (col in model["conts"]){
     
     console.log(effectOfCol)
     
     var xList = []
     var yList = []
     
     for (k in model["conts"][col]){
      xList.push(model["conts"][col][k][0])
      yList.push(model["conts"][col][k][1])
     }
     
     var plotdata = [
     {
      x: xList,
      y: yList,
      type: 'scatter',
      mode: 'lines+markers',
      name: 'Multipliers'
     }
     ]
     
     var layout = {
      title: 'PDP for '+col,
      xaxis: {
       title: col,
      },
      yaxis: {
       title: 'Multiplier',
       range: [Math.min(Math.min(...yList)-leeway, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
      },
      
      height: 600,
      width: 800
      };
     
     Plotly.react("plot_"+col, plotdata, layout)
     
    }
   }
  }


  function getSortedKeys(obj) {
    const keys = Object.keys(obj);
    keys.sort();
    return keys;
  }

  function produce_cont_relevances(inputSeries, cont) { //Note: assumes inputSeries is an array.
    const reles = math.zeros([cont.length + 1, inputSeries.length]);
    
    for (p in inputSeries){
     if (inputSeries[p] < cont[0][0]){
      reles[0][p] = 1
     }
    }
    
    for (let i = 0; i < (cont.length - 1); i++) {
      x1 = cont[i][0];
      x2 = cont[i + 1][0];
      
      for (p in inputSeries){
       x = inputSeries[p]
       if (x>=x1 && x<=x2){
        reles[i][p] = (x2 - x)/(x2 - x1)
        reles[i+1][p] = (x - x1)/(x2 - x1)
       }
      }
    }
    
    for (p in inputSeries){
     if (inputSeries[p] > cont[cont.length-1][0]){
      reles[cont.length-1][p] = 1
     }
    }
    
    for (p in inputSeries){
      s = math.sum(math.subset(reles, math.index(math.range(0, cont.length), Number(p))));
      reles[cont.length][p] = 1-s
    }
    
    return math.transpose(reles); // roundabout way of doing this but the rest of the function doesn't flow as naturally if x and y don't switch places
  }

  function produce_cont_relevances_dict(inputDf, model){
   opDict = {}
   
   
   if ("conts" in model){
    for (col in model["conts"]){
     inputSeries = inputDf.map(d => d[col])
     opDict[col]=produce_cont_relevances(inputSeries, model['conts'][col])
    }
   }
   return opDict
  }

  function produce_cat_relevances(inputSeries, cat) {
    
    skeys = getSortedKeys(cat["uniques"]);
    
    reles = math.zeros([skeys.length + 1, inputSeries.length]);
    
    for (i = 0; i < skeys.length; i++) {
     for (p in inputSeries){
      if (inputSeries[p]===skeys[i]){
       reles[i][p] = 1; //d(featpred)/d(pt)
      }
     }
    }
    
    for (p in inputSeries){
      s = math.sum(math.subset(reles, math.index(math.range(0, skeys.length), Number(p))));
      reles[skeys.length][p] = 1-s
    }
    
    return math.transpose(reles); // roundabout way of doing this but the rest of the function doesn't flow as naturally if x and y don't switch places
  }

  function produce_cat_relevances_dict(inputDf, model){
   opDict = {}
   
   if ("cats" in model){
    for (col in model["cats"]){
     inputSeries = inputDf.map(d => d[col])
     opDict[col]=produce_cat_relevances(inputSeries, model['cats'][col])
    }
   }
   
   return opDict
  }

  function get_effect_of_this_cont_col_from_relevances(reles, model, col, defaultValue=1) {
    let postmultmat = [];
    for (let pt of model["conts"][col]) {
      postmultmat.push(pt[1]);
    }
    postmultmat.push(defaultValue);
    return math.multiply(reles, postmultmat);
  }

  function get_effects_of_cont_cols_from_relevance_dict(releDict, model) {
    let opDict = {};
    if ("conts" in model) {
      for (let col in model["conts"]) {
        opDict[col] = get_effect_of_this_cont_col_from_relevances(releDict[col], model, col);
      }
    }
    return opDict;
  }

  function get_effect_of_this_cat_col_from_relevances(reles, model, col) {
    let skeys = getSortedKeys(model['cats'][col]["uniques"]);
    let postmultmat = [];
    for (let key of skeys) {
      postmultmat.push(model["cats"][col]["uniques"][key]);
    }
    postmultmat.push(model["cats"][col]["OTHER"]);
    return math.multiply(reles, postmultmat);
  }

  function get_effects_of_cat_cols_from_relevance_dict(releDict, model) {
    let opDict = {};
    if ("cats" in model) {
      for (let col in model["cats"]) {
        opDict[col] = get_effect_of_this_cat_col_from_relevances(releDict[col], model, col);
      }
    }
    return opDict;
  }

  function sum_and_listify_matrix(a) {
    return a.reduce((acc, val) => acc.map((x, i) => x + val[i]));
  }

  function produce_total_relevances_dict(contReleDict, catReleDict) {
    let op = { "conts": {}, "cats": {} };
    for (let col in contReleDict) {
      op["conts"][col] = sum_and_listify_matrix(contReleDict[col]);
    }
    for (let col in catReleDict) {
      op["cats"][col] = sum_and_listify_matrix(catReleDict[col]);
    }
    return op;
  }

  function comb_from_effects_mult(base,l,contEffs,catEffs){
   op = new Array(l).fill(base)
   
   for (col in contEffs){
    op = math.dotMultiply(op,contEffs[col])
    
   }
   for (col in catEffs){
    op = math.dotMultiply(op,catEffs[col])
   }
   
   return op
  }

  function Gauss_grad(pred,act){
   return math.multiply(2,math.subtract(pred-act))
  }

  function Poisson_grad(pred,act){
   return math.dotDivide(math.subtract(pred,act),pred)
  }

  function Gamma_grad(pred,act){
   return math.dotDivide(math.subtract(pred,act),math.dotPow(pred,2))
  }
  
  function Tweedie_grad(pred,act){
   pT = document.getElementById("pTweedie").value
   return math.dotDivide(math.subtract(pred,act),math.dotPow(pred,pT))
  }

  function lossgrad(pred,act){
   console.log(pred, act)
   lf = document.getElementById("loss").value
   console.log(lf)
   if (lf==="Gamma"){
   return Gamma_grad(pred,act)
   }
   if (lf==="Poisson"){
   return Poisson_grad(pred,act)
   }
   if (lf==="Tweedie"){
   return Tweedie_grad(pred,act)
   }
  }

  function train(){
   model = document.getElementById("trainModel").value
   model = JSON.parse(model)
   
   target = document.getElementById("trainResp").value
   weight = document.getElementById("trainWei").value
   nrounds = document.getElementById("nrounds").value
   lr = document.getElementById("lr").value
   
   data = document.getElementById("trainData").value
   data = d3.csvParse(data)
   
   document.getElementById("outputSpace").innerHTML = "Preparing . . ."
   
   create_graphSpace()
   
   train_model(data, target, nrounds, lr, model, weight)
  }
  
  function crude_mult(arrayOfArrays, numbersArray){
   
   const resultArray = [];
  
   for (let i = 0; i < arrayOfArrays.length; i++) {
   const innerArray = arrayOfArrays[i];
   const multiplier = numbersArray[i];

   const multipliedArray = innerArray.map(value => value * multiplier);
   resultArray.push(multipliedArray);
   }
   return resultArray
  }
  
  function produce_wReleDict(releDict, wArray){
   resultDict = {};

   for (key in releDict) {
    const arrayOfArrays = releDict[key]
    const multipliedArrays = crude_mult(arrayOfArrays, wArray)
    resultDict[key] = multipliedArrays
   }
   return resultDict
  }
  
  function train_model(inputDf, target, nrounds, lr, model, weight = ""){
   
   wArray=[]
   
   if (weight === "") {
    inputDf.forEach((d) => {
     wArray.push(1);
    });
   } else {
    inputDf.forEach((d) => {
     wArray.push(parseFloat(d[weight]));
    });
   }
   
   console.log(wArray)
   
   cord = produce_cont_relevances_dict(inputDf,model) //d(feat)/d(pt)
   card = produce_cat_relevances_dict(inputDf,model) //d(feat)/d(pt)
   
   for (key in card) {
     console.log(card[key])
   }
   
   console.log(cord)
   console.log(card)
   
   tord = produce_total_relevances_dict(cord, card)
   
   cowrd = produce_wReleDict(cord, wArray)
   cawrd = produce_wReleDict(card, wArray)
   
   towrd = produce_total_relevances_dict(cowrd, cawrd)
   
   resp = inputDf.map(d => d[target])
   
   i=0
   
   function train_one_step(inputDf, target,nrounds,lr,model, i,cord,card,tord,cowrd,cawrd,towrd,resp){
    if (i==nrounds){
     document.getElementById("roundcount").innerHTML = String(nrounds)+"/"+String(nrounds)
     document.getElementById("outputSpace").innerHTML = "Trained Model: "+JSON.stringify(model)
     console.log(model)
    }
    else{
     document.getElementById("roundcount").innerHTML = String(i)+"/"+String(nrounds)
     document.getElementById("outputSpace").innerHTML = "(Partially) Trained Model: "+JSON.stringify(model)
     console.log(model)
     
     contEffects = get_effects_of_cont_cols_from_relevance_dict(cord,model)
     catEffects = get_effects_of_cat_cols_from_relevance_dict(card,model)
     
     pred = comb_from_effects_mult(model["BASE_VALUE"], contEffects.length, contEffects, catEffects)
     
     lossgradient = lossgrad(pred, resp)
     
     if ("conts" in model){
      for (col in model["conts"]){
       effectOfCol = contEffects[col]
       ceoc = math.dotDivide(pred,effectOfCol) //d(comb)/d(feat)
       
       finalGradients = math.multiply(math.dotMultiply(lossgradient,ceoc),cowrd[col]) //d(Loss)/d(pt) = d(Loss)/d(pred) * d(pred)/d(feat) * d(feat)/d(pt)
       
       for (k in model['conts'][col]){
        totRele = towrd["conts"][col][k]
        if (totRele>0){
         model["conts"][col][k][1] -= finalGradients[k]*lr/totRele
        }
       }
      }
     }
     
     if ("cats" in model){
      for (col in model["cats"]){
       
       effectOfCol = catEffects[col]
       ceoc = math.dotDivide(pred,effectOfCol) //d(comb)/d(feat)
       finalGradients = math.multiply(math.dotMultiply(lossgradient,ceoc),cawrd[col]) //d(Loss)/d(pt) = d(Loss)/d(pred) * d(pred)/d(feat) * d(feat)/d(pt)
       
       skeys = getSortedKeys(model['cats'][col]["uniques"])
       
       for (k in skeys){
        totRele = towrd["cats"][col][k]
        
        
        
        if (totRele>0){
         model["cats"][col]["uniques"][skeys[k]] -= finalGradients[k]*lr/totRele
        }
       }
       
       totRele = tord["cats"][col][towrd["cats"][col].length-1]
       if (totRele>0){
        model["cats"][col]["OTHER"] -= finalGradients[finalGradients.length-1]*lr/totRele
       }
      }
     }
     update_graphs(model)
     
     i++
     setTimeout(train_one_step, 0, inputDf, target,nrounds,lr,model, i,cord,card,tord,cowrd,cawrd,towrd,resp)
     }
    }
    train_one_step(inputDf, target,nrounds,lr,model, i,cord,card,tord,cowrd,cawrd,towrd,resp)
  }
  
  //Functions for Predict
  
  function range(r){
   return Array(r).fill(1).map((x, y) => x + y - 1)
  }

  leeway=0.05
  defaultValue=1
  targetSpan=0.5


  function init_inputSpace(model){
   if ("cats" in model){
    for (col in model["cats"]){
     console.log(col)
     
     document.getElementById("predictInputSpace").innerHTML += "<br>"
     document.getElementById("predictInputSpace").innerHTML += '<div id="predictPlot_'+col+'"></div>'
     document.getElementById("predictInputSpace").innerHTML += "<br>"
     document.getElementById("predictInputSpace").innerHTML += '<div id="predictInput_'+col+'"></div>'
     
    }
   }
   if ("conts" in model){
    for (col in model["conts"]){
     console.log(col)
     
     document.getElementById("predictInputSpace").innerHTML += "<br>"
     document.getElementById("predictInputSpace").innerHTML += '<div id="predictPlot_'+col+'"></div>'
     document.getElementById("predictInputSpace").innerHTML += "<br>"
     document.getElementById("predictInputSpace").innerHTML += '<div id="predictInput_'+col+'"></div>'
    }
   }
  }

  function create_inputSpace(botherWithGraphs){
   
   if (botherWithGraphs){
    document.getElementById('pSingle').style.color = defaultButtonText
    document.getElementById('pSingle').style.backgroundColor = defaultButtonBackground
    document.getElementById('pGraphs').style.color = "white"
    document.getElementById('pGraphs').style.backgroundColor = "black"
    document.getElementById('pDataset').style.color = defaultButtonText
    document.getElementById('pDataset').style.backgroundColor = defaultButtonBackground
   }
   else{
    document.getElementById('pSingle').style.color = "white"
    document.getElementById('pSingle').style.backgroundColor = "black"
    document.getElementById('pGraphs').style.color = defaultButtonText
    document.getElementById('pGraphs').style.backgroundColor = defaultButtonBackground
    document.getElementById('pDataset').style.color = defaultButtonText
    document.getElementById('pDataset').style.backgroundColor = defaultButtonBackground
   }
   
   model = document.getElementById("predictModel").value
   model = JSON.parse(model)
   document.getElementById("predictInputSpace").innerHTML = ""
   document.getElementById("predictEffects").innerHTML = ""
   document.getElementById("predictOutput").innerHTML = ""
   init_inputSpace(model)
    
    
    if ("cats" in model){
     for (col in model["cats"]){
      console.log(col)
      
      if (botherWithGraphs){
       var xList = []
       var yList = []
       
       for (k in model["cats"][col]["uniques"]){
        xList.push(k)
        yList.push(model["cats"][col]["uniques"][k])
       }
       if (model["cats"][col].hasOwnProperty("OTHER")){
        xList.push("OTHER")
        yList.push(model["cats"][col]["OTHER"])
       }
       
       var plotdata = [
       {
        x: xList,
        y: yList,
        type: 'bar'
       }
       ]
       
       var layout = {
       title: 'PDP for '+col,
       xaxis: {
        title: col,
       },
       yaxis: {
        title: 'Multiplier',
        range: [Math.min(Math.min(...yList)-leeway, 0, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
       },
       
       height: 600,
       width: 800
       };
       
       Plotly.newPlot("predictPlot_"+col, plotdata, layout)
       }
      document.getElementById("predictInput_"+col).innerHTML += ""+col
      document.getElementById("predictInput_"+col).innerHTML += ': <input type="text" id="dat_'+col+'"><span id="effectStat_'+col+'"></span>'
     }
    }
    if ("conts" in model){
     for (col in model["conts"]){
      console.log(col)
      
      if (botherWithGraphs){
       
       var xList = []
       var yList = []
       
       for (k in model["conts"][col]){
        xList.push(model["conts"][col][k][0])
        yList.push(model["conts"][col][k][1])
       }
       
       
       var plotdata = [
       {
        x: xList,
        y: yList,
        type: 'scatter',
        mode: 'lines+markers'
       }
       ]
       
       var layout = {
       title: 'PDP for '+col,
       xaxis: {
        title: col,
       },
       yaxis: {
        title: 'Multiplier',
        range: [Math.min(Math.min(...yList)-leeway, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
       },
       
       height: 600,
       width: 800
       };
       
       Plotly.newPlot("predictPlot_"+col, plotdata, layout)
      }
      
      document.getElementById("predictInput_"+col).innerHTML += ""+col
      document.getElementById("predictInput_"+col).innerHTML += ': <input type="number" id="dat_'+col+'"><span id="effectStat_'+col+'"></span>'
     }
    }
   if (botherWithGraphs){
    document.getElementById("predictInputSpace").innerHTML +='<br><br><button onclick="predict_single(true)">Predict</button>'
   }
   else{
    document.getElementById("predictInputSpace").innerHTML +='<br><br><button onclick="predict_single(false)">Predict</button>'
   }
   //})
   //console.log(document.getElementById("inputSpace").innerHTML)
  }

  function predict_single(botherWithGraphs) {
   model = document.getElementById("predictModel").value
   model = JSON.parse(model)
   console.log('m',model)
   ipd = {}
   console.log(document.getElementById("predictInputSpace").innerHTML)
   if ("cats" in model){
    for (col in model["cats"]){
     ipd[col] = document.getElementById("dat_"+col).value
    }
   }
   if ("conts" in model){
    for (col in model["conts"]){
     ipd[col] = parseFloat(document.getElementById("dat_"+col).value)
    }
   }
   
   p = predict_mult_flashily(model, ipd, botherWithGraphs)
   console.log(ipd)
   
   
   document.getElementById("predictOutput").innerHTML = "Predicted value of response variable: " + Math.round(p*100)/100
   console.log('p',p)
  }

  function predict_mult(model, inputDict) {
   pred = model["BASE_VALUE"]
   if ("cats" in model){
    for (col in model["cats"]){
     effectOfCol = get_effect_of_cat_on_single_input(inputDict[col], model['cats'][col])
     console.log(effectOfCol)
     pred = pred*effectOfCol
    }
   }
   if ("conts" in model){
    for (col in model["conts"]){
     effectOfCol = get_effect_of_cont_on_single_input(inputDict[col], model['conts'][col])
     console.log(effectOfCol)
     pred = pred*effectOfCol
    }
   }
   return pred
  }

  function predict_mult_flashily(model, inputDict, botherWithGraphs) {
   pred = model["BASE_VALUE"]
   
   document.getElementById("predictEffects").innerHTML = ""+model["BASE_VALUE"]+ " * "
   
   if ("cats" in model){
    for (col in model["cats"]){
     
     effectOfCol = get_effect_of_cat_on_single_input(inputDict[col], model['cats'][col])
     
     document.getElementById("effectStat_"+col).innerHTML = (" Multiplier from this feature is "+Math.round(effectOfCol*10000)/10000)
     document.getElementById("predictEffects").innerHTML += (""+(Math.round(effectOfCol*10000)/10000)+" * ")
     
     if (botherWithGraphs){
      
      var xList = []
      var yList = []
      
      if (inputDict[col] in model['cats'][col]["uniques"]){
       xOfCol = inputDict[col]
      }
      else{
       xOfCol = "OTHER"
      }
      
      
      for (k in model["cats"][col]["uniques"]){
       xList.push(k)
       yList.push(model["cats"][col]["uniques"][k])
      }
      if (model["cats"][col].hasOwnProperty("OTHER")){
       xList.push("OTHER")
       yList.push(model["cats"][col]["OTHER"])
      }
      
      var plotdata = [
      {
       x: xList,
       y: yList,
       type: 'bar',
       name: 'Multipliers'
      },
      {
       x:[xOfCol],
       y:[effectOfCol],
       type: 'scatter',
       mode: 'markers',
       name: 'Effect on prediction',
       marker: {
         color: 'red',
         symbol: 'square',
         size: 10
       }
      }
      ]
      
      var layout = {
      title: 'PDP for '+col,
      xaxis: {
       title: col,
      },
      yaxis: {
       title: 'Multiplier',
       range: [Math.min(Math.min(...yList)-leeway, 0, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
      },
      
      height: 600,
      width: 800
      };
      
      Plotly.react("predictPlot_"+col, plotdata, layout)
     }
     
     console.log(effectOfCol)
     pred = pred*effectOfCol
    }
   }
   if ("conts" in model){
    for (col in model["conts"]){
     
     effectOfCol = get_effect_of_cont_on_single_input(inputDict[col], model['conts'][col])
     
     document.getElementById("effectStat_"+col).innerHTML = (" Multiplier from this feature is "+Math.round(effectOfCol*10000)/10000)
     document.getElementById("predictEffects").innerHTML += (""+(Math.round(effectOfCol*10000)/10000)+" * ")
     
     if (botherWithGraphs){
      
      var xList = []
      var yList = []
      
      for (k in model["conts"][col]){
       xList.push(model["conts"][col][k][0])
       yList.push(model["conts"][col][k][1])
      }
      
      var plotdata = [
      {
       x: xList,
       y: yList,
       type: 'scatter',
       mode: 'lines+markers',
       name: 'Multipliers'
      },
      {
       x:[inputDict[col]],
       y:[effectOfCol],
       type: 'scatter',
       mode: 'markers',
       name: 'Effect on prediction',
       marker: {
         color: 'red',
         symbol: 'square',
         size: 10
       }
      }
      ]
      
      var layout = {
       title: 'PDP for '+col,
       xaxis: {
        title: col,
       },
       yaxis: {
        title: 'Multiplier',
        range: [Math.min(Math.min(...yList)-leeway, defaultValue-targetSpan), Math.max(Math.max(...yList)+leeway, defaultValue+targetSpan)]
       },
       
       height: 600,
       width: 800
       };
      
      Plotly.react("predictPlot_"+col, plotdata, layout)
     }
     pred = pred*effectOfCol
    }
   }
   
   document.getElementById("predictEffects").innerHTML = document.getElementById("predictEffects").innerHTML.slice(0,-3) + " = "
   
   return pred
  }
  
  
  function create_dataset_inputSpace(){
   
   document.getElementById('pSingle').style.color = defaultButtonText
   document.getElementById('pSingle').style.backgroundColor = defaultButtonBackground
   document.getElementById('pGraphs').style.color = defaultButtonText
   document.getElementById('pGraphs').style.backgroundColor = defaultButtonBackground
   document.getElementById('pDataset').style.color = "white"
   document.getElementById('pDataset').style.backgroundColor = "black"
   
   document.getElementById("predictInputSpace").innerHTML = ""
   document.getElementById("predictEffects").innerHTML = ""
   document.getElementById("predictOutput").innerHTML = ""
   
   document.getElementById("predictInputSpace").innerHTML = '<br><br><span class="tooltip">Data<span class="tooltiptext">Copypaste your dataset here (must be in csv format).</span></span>: <textarea id="predictData" rows= 20 style="height: auto; width: 400px">Width,Height,Icing Thickness,Flavour,Wedding,Fancy,Price&#13;&#10;6,10,10,chocolate,Yes,No,5.59&#13;&#10;12,8,7,vanilla,No,No,51.8&#13;&#10;6,8,10,vanilla,No,No,6.55&#13;&#10;7,4,8,vanilla,No,Somewhat,10.13</textarea>'
   

   document.getElementById("predictInputSpace").innerHTML +='<br><br><button onclick="predict_multiple()">Predict</button>'
  }
  
  function get_effect_of_cat_on_single_input(input,cat){
   if (input in cat["uniques"]){
    return cat["uniques"][input]
   }
   return cat["OTHER"]
  }

  function get_effect_of_cont_on_single_input(x, cont){
   console.log(cont,x)
   if (x<=cont[0][0]){
    return cont[0][1]} //everything outside our scope is flat
   for (var i = 0; i < (cont.length-1); i++){
    console.log(cont[i], cont[i+1])
    if (x>=cont[i][0] && x<=cont[i+1][0]){
     return ((x-cont[i][0])*cont[i+1][1] + (cont[i+1][0]-x)*cont[i][1])/(cont[i+1][0]-cont[i][0])}} //((x-p1)y1 + (p2-x)y2) / (p2 - p1)
   if (x>=cont[cont.length-1][0]){
    return cont[cont.length-1][1] //everything outside our scope is flat
   }
  }
  
  function predict_multiple() {
   model = document.getElementById("predictModel").value
   model = JSON.parse(model)
   data = document.getElementById("predictData").value
   console.log(data)
   data = d3.csvParse(data)
   
   document.getElementById("predictOutput").innerHTML = "Dataset with prediction column: <br><br>"
   
   output = data.map(function(d) {
    d["PREDICTED"] = Math.round(predict_mult(model, d)*1000000)/1000000
    return d
   });
   console.log(output)
   
   output = d3.csvFormat(output)
   
   d3.select("#predictOutput")
          .append("pre")
          .text(output);
  }
  
  
  </script>
  
</body>
</html>
